token.add = function(row, col, team, size = 3.5){
color = c("black", "firebrick")[team]
points(col - 0.5, row - 0.5, pch = 19, col = color, cex = size)
}
board.4c = function(n_row, n_col){
b.1 = as.matrix(expand.grid(2, c(1:3)))
b.2 = as.matrix(expand.grid(c(1,6,7), c(1:6)))
b.3 = as.matrix(expand.grid(c(3,4), c(1,2,3,5,6)))
black = cbind(rbind(b.1, b.2, b.3), rep(1, (nrow(b.1) + nrow(b.2) + nrow(b.3))))
r.1 = as.matrix(expand.grid(5, c(1:n_row)))
r.2 = matrix(c(2,2,2,3,4,6,5,4,4,4), ncol = 2)
red = cbind(rbind(r.1, r.2), rep(2, (nrow(r.1) + nrow(r.2))))
coords = rbind(black, red)
ord = sample(c(1:(n_row * n_col)))
board.new(n_row, n_col)
for(i in ord){
token.add(coords[i,2], coords[i,1], coords[i,3], size = 2)
Sys.sleep(0.05)
}
}
rules.print = function(){
cat("These are the rules")
}
game.initialize = function(n_row, n_col, n_player){
cat("Hi there! My name is Commander Data! \n What's up? \n I heard you want to play my brandnew game")
for(i in 1:5){
cat("... \n")
Sys.sleep(0.5)
}
cat(
"4 - CONNECT"
)
board.4c(n_row, n_col)
for(i in 1:5){
cat("... \n")
Sys.sleep(0.5)
}
cat("So, you know my name. I'd like to know yours, too. But first:\n
You can play against a friend or against me. What do you choose?\n
Ah, I see! You already chose!\n")
if(n_player == 1){
cat("Please, tell me your name. You can communicate with me via the console!\n")
player_name_1 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("Welcome to the game, ", player_name_1, "!\n"))
cat("I'll enjoy playing with you!\n")
player_name_2 = "Commander Data"
} else if(n_player == 2){
cat("I'm glad that I can watch you two play. Please, tell me your names. You can communicate with me via the console! \n
Player 1:\n")
player_name_1 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("Welcome to the game, ", player_name_1,"!\n"))
cat("Player 2:\n")
player_name_2 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("You're welcome, too, ", player_name_2, "!\n"))
}
cat("So, let's start the game!\n" )
rules.hear = "a"
while(!rules.hear %in% c("yes", "start")){
cat("If you want to hear the rules again, type >>yes<<, if you want to start immediately, type >>start<<!\n")
rules.hear = scan(what = "character", nlines = 1, quiet = T)
if(length(rules.hear) == 0){
cat("Error. Unfortunately, I could not understand what you said.\n")
} else if(rules.hear == "yes"){
game_start = character(0)
rules.print()
while(length(game_start)==0){
cat("To start type anything (no space) into the console and press enter whenever you are ready to rumble!")
game_start = scan(what = "character", nlines = 1, quiet = T)
}
board.new(n_row, n_col)
} else if(rules.hear == "start"){
board.new(n_row, n_col)
} else {
cat("Error. Unfortunately, I could not understand what you said.\n")
}
}
player.order = sample(c(1,2))
start_move <- player.order[1]
player_names <<- c(player_name_1, player_name_2)
match_status <<- 1
cat(paste0(player_name_1, " VS. ", player_name_2, "\n"))
cat(paste0("Player ", start_move, " (", player_names[start_move], ") starts! \n In each move you have to choose one column!\n"))
moves_played <<- matrix(NA, ncol = 2, nrow = n_row*n_col)
colnames(moves_played) = player_names[player.order]
column_counts <<- rep(0, n_col)
field_mat <<- matrix(0, ncol = n_col, nrow = n_row)
move_seq <<-  rep(player.order, (n_col * n_row) / 2)
#if(start_move == 2) move_seq <<- (move_seq %% 2) + 1
}
rm(list = ls())
#### Script for connect four
connect_four = function(n_row = 6, n_col = 7, n_player = 2){
suppressWarnings(rm(match_status, player_names, start_move))
game_status   <- 1
match_status <<- 0
while(game_status == 1){
game.initialize(n_row, n_col, n_player)
while(match_status == 1){
for(i in 1:length(move_seq)){
current_move = move_seq[i]
col.cur = 0
while(!col.cur %in% c(1:n_col)){
if(n_player == 1 && current_move == 2){
col.cur = computer.play(field_mat, column_counts)
} else {
cat(paste0(player_names[current_move], " (Player ", current_move, "), it's your turn. Select a column!"))
col.cur = scan(nlines = 1, quiet =  T)
Sys.sleep(0.5)
if(!col.cur %in% c(1:n_col)) cat("There is no such column. Try again!")
if(column_counts[col.cur] == n_row) cat("This column is already full. Try again!")
}
}
column_counts[col.cur] <<- column_counts[col.cur] + 1
field_mat[n_row + 1 - column_counts[col.cur], col.cur] <<- current_move
moves_played[i, current_move] <<- col.cur
token.add(column_counts[col.cur], col.cur, current_move)
cat(paste0("Player ", current_move, " - " , player_names[current_move], " chooses column ", col.cur, "\n"))
if(i >= 7 && i < length(move_seq)){
check_win = check.win(field_mat, column_counts)
if(check_win$check == T){
match_status <<- 0
token.win(check_win, field_mat)
winner_greet = paste0("Player ", current_move, " - ", player_names[current_move], "\n")
break()
}
}
if(i == length(move_seq)){
check_win = check.win(field_mat, column_counts)
if(check_win$check == F){
match_status <<- 0
cat("There is a tie! Nobody won. \n")
}
if(check_win$check == T){
match_status <<- 0
token.win(check_win, field_mat)
winner_greet = paste0("Player ", current_move, " - ", player_names[current_move], "\n")
break()
}
}
}
}
cat("GAME OVER! \n The winner is: \n")
cat("... \n")
cat(winner_greet)
cat("Do you want to save the match locally as .RData? \n
>>yes<< or >>no<< \n")
save_file = scan(nlines = 1, quiet = T)
if(save_file == "yes"){
game.save(field_mat, moves_played, check_win)
cat("Successfully saved file \n")
}
cat("Do you want to take a rematch? \n
>>yes<< or >>no<< \n")
rematch = scan(nlines = 1, quiet = T)
if(rematch != "yes"){
game_status <- 0
winner_greet = "Goodbye!"
}
}
}
game.reset = function(){
rm(match_status, start_move, moves_played, field_mat, moves_seq, column_counts)
match_status <<- 1
}
game.save = function(field_mat, moves_played, check_win){
file_name = paste0("4connect_", format(Sys.time(), format = "%Y_%m_%d_%H_%M_%S"), ".RData")
save(file = file_name, list = c(field_mat, moves_played, check_win))
cols_team = c("black", "firebrick")
png(filename = paste0(file_name, ".png"), width = 1280, height = 720)
board.new()
for(i in 1:nrow(field_mat)){
for(j in 1:ncol(field_mat)){
token.add(i, j, field_mat[i, j])
}
}
points(check_win$coords - 0.5, pch = 4, col = "darkgreen", cex = 3.5)
dev.off()
}
token.win = function(check_win, field_mat){
n_row_c = nrow(field_mat)
x_coord = check_win$coords[,1] - 0.5
y_coord = check_win$coords[,2] - 0.5
points(x = x_coord, y = y_coord, pch = 4, col = "darkgreen", cex = 3.5, lwd = 2)
}
computer.play = function(field_mat, column_counts){
play_col = 0
win_play = computer.play.win(field_mat, column_counts, play_col)
if(win_play > 0){
play_col = win_play
} else {
play_col = computer.play.lose(field_mat, column_counts, play_col)
}
# for each column where a disc can be dropped check whether computer can win or player 1 could win;
# otherwise choose randomly
if(play_col == 0){
sample_cols = which(column_counts < nrow(field_mat))
play_col = sample(sample_cols, size = 1)
}
return(play_col)
}
computer.play.win = function(field_mat, column_counts, play_col){
play_col = play_col
for(k in 1:length(column_counts)){
column_check = column_counts # The copied data has to be in loop in order to erase thew new added stuff again; otherwise the computer
field_check  = field_mat     # could detect a win where no one is
if(column_check[k] < nrow(field_check)){
column_check[k] = column_check[k] + 1
field_check[nrow(field_check) + 1 - column_check[k], k] = 2
check_play = check.win(field_check, column_check)
if(check_play$check == T){
play_col = k
break()
}
} else next()
}
return(play_col)
}
computer.play.lose = function(field_mat, column_counts, play_col){
play_col = play_col
for(k in 1:length(column_counts)){
column_check = column_counts # The copied data has to be in loop in order to erase thew new added stuff again; otherwise the computer
field_check  = field_mat     # could detect a win where no one is
if(column_check[k] < nrow(field_check)){
column_check[k]   = column_check[k] + 1
field_check[nrow(field_check) + 1 - column_check[k], k] = 1
check_play = check.win(field_check, column_check)
if(check_play$check == T){
play_col = k
break()
}
} else next()
}
return(play_col)
}
diag.low = function(mat){
n = nrow(mat)
k = ncol(mat)
if(k != n) stop("Matrix must be square")
diag = numeric(n)
seq_d  = seq(n, 1, -1)
for(i in 1:n){
diag[i] = mat[seq_d[i], i]
}
return(diag)
}
check.win = function(field_mat, column_counts){
n_row_c = nrow(field_mat)
win = F
return_list = list()
cum_counts = cumsum(column_counts)
cum_check = cum_counts - c(0,0,0,0, cum_counts[-c((length(column_counts) - 3):length(column_counts))])
# diagonal
r_max = max(column_counts)
# check left diag (left top to bottom right)
if(r_max >= 4){
stop_loop = F
for(j in 4:r_max){
for(z in 1:(ncol(field_mat) - 3)){
diag_check = diag(field_mat[c((n_row_c + 4 - j):(n_row_c + 1 - j)), c(z:(z+3))])
if(any(diag_check == 0)) next()
if(length(unique(diag_check)) == 1){
win = T
return_list$type = "diagonal"
return_list$coords = data.frame(x = c(z:(z+3)), y = c((j-3):j))
stop_loop = T
break()
}
}
if(stop_loop == T) break()
}
}
# check right diag (left bottom to top right)
if(r_max >= 4){
stop_loop = F
for(j in 4:r_max){
for(z in 1:(ncol(field_mat) - 3)){
diag_check = diag.low(field_mat[c((n_row_c + 4 - j):(n_row_c + 1 - j)), c(z:(z+3))])
if(any(diag_check == 0)) next()
if(length(unique(diag_check)) == 1){
win = T
return_list$type = "diagonal"
return_list$coords = data.frame(x = c(z:(z+3)), y = c(j:(j+3)))
stop_loop = T
break()
}
}
if(stop_loop == T) break()
}
}
row_check = apply(field_mat, 1, function(x) length(x[x!=0]))
if(any(row_check >= 4)){
row_id = which(row_check >= 4)
if(length(row_id) > 1){
row_check_fin = apply(field_mat[row_id,], 1, function(x){
l = NA
for(j in 4:ncol(field_mat)){
if(any(x[c((j-3):j)] == 0)){
next()
} else if(length(unique(x[c((j-3):j)])) == 1){
l = j
}
}
return(l)
}
)
} else {
row_check_fin = NA
x = field_mat[row_id,]
for(j in 4:length(x)){
if(any(x[c((j-3):j)] == 0)){
next()
} else if(length(unique(x[c((j-3):j)])) == 1){
row_check_fin = j
}
}
}
if(any(!is.na(row_check_fin))){
cols = row_check_fin[!is.na(row_check_fin)]
win = T
return_list$type = "row"
return_list$coords = data.frame(x = c((cols-3):cols), y = row_id[cols])
}
}
if(any(column_counts >= 4)){
id_col = which(column_counts >= 4)
for(j in 1:length(id_col)){
cols = field_mat[n_row_c + c(1:4) - column_counts[id_col[j]] , id_col[j]]
if(length(unique(cols)) == 1){
win = T
return_list$type = "column"
return_list$coords = data.frame(x = id_col[j], y = column_counts[id_col[j]] - c(0:3))
break()
}
}
}
return_list$check = win
return(return_list)
}
board.new = function(n_row, n_col){
plot(0, type = "n", ylim = c(0, n_row), xlim = c(0, n_col), xaxt = "n", yaxt = "n", main = "", ylab = "", xlab = "", xaxs = "i", yaxs = "i")
axis(3, at = seq(0.5, n_col - 0.5, 1), c(1:7), tick = F)
axis(2, at = seq(0.5, n_row - 0.5, 1), c(1:6), tick = F)
title("Connect Four", line = 2.5, font.main = 1)
grid(n_col, n_row, col = "darkgrey")
}
token.add = function(row, col, team, size = 3.5){
color = c("black", "firebrick")[team]
points(col - 0.5, row - 0.5, pch = 19, col = color, cex = size)
}
board.4c = function(n_row, n_col){
b.1 = as.matrix(expand.grid(2, c(1:3)))
b.2 = as.matrix(expand.grid(c(1,6,7), c(1:6)))
b.3 = as.matrix(expand.grid(c(3,4), c(1,2,3,5,6)))
black = cbind(rbind(b.1, b.2, b.3), rep(1, (nrow(b.1) + nrow(b.2) + nrow(b.3))))
r.1 = as.matrix(expand.grid(5, c(1:n_row)))
r.2 = matrix(c(2,2,2,3,4,6,5,4,4,4), ncol = 2)
red = cbind(rbind(r.1, r.2), rep(2, (nrow(r.1) + nrow(r.2))))
coords = rbind(black, red)
ord = sample(c(1:(n_row * n_col)))
board.new(n_row, n_col)
for(i in ord){
token.add(coords[i,2], coords[i,1], coords[i,3], size = 2)
Sys.sleep(0.05)
}
}
rules.print = function(){
cat("These are the rules")
}
game.initialize = function(n_row, n_col, n_player){
cat("Hi there! My name is Commander Data! \n What's up? \n I heard you want to play my brandnew game")
for(i in 1:5){
cat("... \n")
Sys.sleep(0.5)
}
cat(
"4 - CONNECT"
)
board.4c(n_row, n_col)
for(i in 1:5){
cat("... \n")
Sys.sleep(0.5)
}
cat("So, you know my name. I'd like to know yours, too. But first:\n
You can play against a friend or against me. What do you choose?\n
Ah, I see! You already chose!\n")
if(n_player == 1){
cat("Please, tell me your name. You can communicate with me via the console!\n")
player_name_1 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("Welcome to the game, ", player_name_1, "!\n"))
cat("I'll enjoy playing with you!\n")
player_name_2 = "Commander Data"
} else if(n_player == 2){
cat("I'm glad that I can watch you two play. Please, tell me your names. You can communicate with me via the console! \n
Player 1:\n")
player_name_1 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("Welcome to the game, ", player_name_1,"!\n"))
cat("Player 2:\n")
player_name_2 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("You're welcome, too, ", player_name_2, "!\n"))
}
cat("So, let's start the game!\n" )
rules.hear = "a"
while(!rules.hear %in% c("yes", "start")){
cat("If you want to hear the rules again, type >>yes<<, if you want to start immediately, type >>start<<!\n")
rules.hear = scan(what = "character", nlines = 1, quiet = T)
if(length(rules.hear) == 0){
cat("Error. Unfortunately, I could not understand what you said.\n")
} else if(rules.hear == "yes"){
game_start = character(0)
rules.print()
while(length(game_start)==0){
cat("To start type anything (no space) into the console and press enter whenever you are ready to rumble!")
game_start = scan(what = "character", nlines = 1, quiet = T)
}
board.new(n_row, n_col)
} else if(rules.hear == "start"){
board.new(n_row, n_col)
} else {
cat("Error. Unfortunately, I could not understand what you said.\n")
}
}
player.order = sample(c(1,2))
start_move <- player.order[1]
player_names <<- c(player_name_1, player_name_2)
match_status <<- 1
cat(paste0(player_name_1, " VS. ", player_name_2, "\n"))
cat(paste0("Player ", start_move, " (", player_names[start_move], ") starts! \n In each move you have to choose one column!\n"))
moves_played <<- matrix(NA, ncol = 2, nrow = n_row*n_col)
colnames(moves_played) = player_names[player.order]
column_counts <<- rep(0, n_col)
field_mat <<- matrix(0, ncol = n_col, nrow = n_row)
move_seq <<-  rep(player.order, (n_col * n_row) / 2)
#if(start_move == 2) move_seq <<- (move_seq %% 2) + 1
}
connect_four()
z = 1
j = 4
return_list$coords = data.frame(x = c(z:(z+3)), y = c((j-3):j))
return_list = list()
return_list$coords = data.frame(x = c(z:(z+3)), y = c((j-3):j))
token.win(return_list, field_mat)
return_list$coords = data.frame(x = c(z:(z+3)), y = seq(j, (j-3), 1))
return_list$coords = data.frame(x = c(z:(z+3)), y = seq(j, (j-3), -1))
token.win(return_list, field_mat)
4 * 10000 - 2
(4 * 10000 - 2) / (3 * 10000 +)
(4 * 10000 - 2) / (3 * 10000 + 1)
A = matrix(c(1:10), ncol = 2)
A
b = c(1:5)
A * b
test.mom = function(x, nboot){
x.boot = x - mean(x)
z = matrix(sample(c(-1,1), size = nboot * length(x), replace = T), ncol = nboot)
z.boot = x.boot * z
z.mean = colMeans(z.boot)
z.var  = ( colSums(z.boot^2) - length(x) * z.mean^2 ) / (length(x) - 1)
return(c(mean(z.mean), mean(z.var)))
}
x = rnorm(20, 3, 5)
test.mom(x)
test.mom(x, 1000)
test.mom = function(x, nboot){
x.boot = x - mean(x)
z = matrix(sample(c(-1,1), size = nboot * length(x), replace = T), ncol = nboot)
z.boot = x.boot * z
z.mean = colMeans(z.boot)
z.var  = ( colSums(z.boot^2) - length(x) * z.mean^2 ) / (length(x) - 1)
return(c(mean(z.mean) + mean(x), mean(z.var)))
}
test.mom(rnorm(10, 3, 5), 1000)
test.mom(rnorm(10, 3, 5), 1000)
test.mom(rnorm(10, 3, 5), 1000)
test.mom(rnorm(10, 3, 5), 1000)
test.mom(rnorm(10, 3, 5), 1000)
test.mom(rnorm(10, 3, 5), 1000)
test.mom(rnorm(10, 3, 5), 1000)
test.mom(rnorm(10, 3, 5), 1000)
ab = replicate(1000, test.mom(rnorm(10, 3, 5), 1000))
rowMeans(ab)
?quantile
citation("stats")
?sort
?tapply
?sd
devtools::install_github("spruenke/nboot")
devtools::install_github("spruenke/nboot")
nboot:rowQuant
A = matrix(rnorm(30), ncol = 6)
apply(A, 2, quantile, probs = c(0.25, 0.75))
nboot::colQuant(A, probs = c(0.25, 0.75))
?colQuant
getwd()
setwd("D:/Dropbox/Studium/M.Sc. Statistics/Semester III/NIC/code")
library(Rcpp)
sourceCpp("summary_cpp.cpp")
x = rnorm(10)
summaryBoot(x, 1000)
summary(x)
sd(x)
# True values
q.025 = qnorm(0.25)
q.025
nboots = c(10, 100, 500, 1000, 10000) # define different bootstrap iterations
n      = c(5, 10, 15, 20, 50, 100, 200) # define different sample sizes
expand.grid(nboots, n)
?expand.grid
dat    = expand.grid(nboots, n)
colnames(dat) = c("nboots", "n")
View(dat)
dat$speed = NA
dat = dat[,-3]
