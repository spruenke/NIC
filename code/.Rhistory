}
}
# check right diag (left bottom to top right)
if(r_max >= 4){
stop_loop = F
for(j in 4:r_max){
for(z in 1:(ncol(field_mat) - 3)){
diag_check = diag.low(field_mat[n_row_c + c(1:4) - j, c(z:(z+3))])
if(any(diag_check == 0)) next()
if(length(unique(diag_check)) == 1){
win = T
return_list$type = "diagonal"
return_list$coords = data.frame(x = c(z:(z+3)), y = c((j-3):j))
stop_loop = T
break()
}
}
if(stop_loop == T) break()
}
}
# rows
row_check = apply(field_mat, 1, function(x) length(x[x!=0]))
if(any(row_check >= 4)){
row_id = which(row_check >= 4)
if(length(row_id) > 1){
row_check_fin = apply(field_mat[row_id,], 1, function(x){
l = NA
for(j in 4:ncol(field_mat)){
if(any(x[c((j-3):j)] == 0)){
next()
} else if(length(unique(x[c((j-3):j)])) == 1){
l = j
}
}
return(l)
}
)
row_win = which(!is.na(row_check_fin))
} else {
row_check_fin = NA
x = field_mat[row_id,]
for(j in 4:length(x)){
if(any(x[c((j-3):j)] == 0)){
next()
} else if(length(unique(x[c((j-3):j)])) == 1){
row_check_fin = j
}
}
row_win = row_id
}
if(any(!is.na(row_check_fin))){
cols = row_check_fin[!is.na(row_check_fin)]
win = T
return_list$type = "row"
return_list$coords = data.frame(x = c((cols-3):cols), y = row_win)
}
}
# columns
if(any(column_counts >= 4)){
id_col = which(column_counts >= 4)
for(j in 1:length(id_col)){
cols = field_mat[n_row_c + c(1:4) - column_counts[id_col[j]] , id_col[j]]
if(length(unique(cols)) == 1){
win = T
return_list$type = "column"
return_list$coords = data.frame(x = id_col[j], y = column_counts[id_col[j]] - c(0:3))
break()
}
}
}
return_list$check = win
return(return_list)
}
board.new = function(n_row, n_col){
plot(0, type = "n", ylim = c(0, n_row), xlim = c(0, n_col), xaxt = "n", yaxt = "n", main = "", ylab = "", xlab = "", xaxs = "i", yaxs = "i")
axis(3, at = seq(0.5, n_col - 0.5, 1), c(1:7), tick = F)
axis(2, at = seq(0.5, n_row - 0.5, 1), c(1:6), tick = F)
title("Connect Four", line = 2.5, font.main = 1)
grid(n_col, n_row, col = "darkgrey")
}
token.add = function(row, col, team, size = 3.5){
color = c("black", "firebrick")[team]
points(col - 0.5, row - 0.5, pch = 19, col = color, cex = size)
}
board.4c = function(n_row, n_col){
b.1 = as.matrix(expand.grid(2, c(1:3)))
b.2 = as.matrix(expand.grid(c(1,6,7), c(1:6)))
b.3 = as.matrix(expand.grid(c(3,4), c(1,2,3,5,6)))
black = cbind(rbind(b.1, b.2, b.3), rep(1, (nrow(b.1) + nrow(b.2) + nrow(b.3))))
r.1 = as.matrix(expand.grid(5, c(1:n_row)))
r.2 = matrix(c(2,2,2,3,4,6,5,4,4,4), ncol = 2)
red = cbind(rbind(r.1, r.2), rep(2, (nrow(r.1) + nrow(r.2))))
coords = rbind(black, red)
ord = sample(c(1:(n_row * n_col)))
board.new(n_row, n_col)
for(i in ord){
token.add(coords[i,2], coords[i,1], coords[i,3], size = 2)
Sys.sleep(0.05)
}
}
rules.print = function(){
cat("These are the rules: \n
* Each move, the current player has to drop her disc into a column of choice \n
* The disc falls straight down on top of the highest disc in that column \n
* If the column is full, no disc can be dropped there \n
* The objective is to form a horizontal, vertical or diagonal line of four of the own discs \n
* If there is no free cell and no line of four of one's disc, the game ends in a tie \n
")
}
game.initialize = function(n_row, n_col, n_player){
cat("Hi there! My name is Commander Data! \n What's up? \n I heard you want to play my brandnew game")
for(i in 1:5){
cat("... \n")
Sys.sleep(0.5)
}
cat(
"4 - CONNECT"
)
board.4c(n_row, n_col)
for(i in 1:5){
cat("... \n")
Sys.sleep(0.5)
}
cat("So, you know my name. I'd like to know yours, too. But first:\n
You can play against a friend or against me. What do you choose?\n
Ah, I see! You already chose!\n")
if(n_player == 1){
cat("Please, tell me your name. You can communicate with me via the console!\n")
player_name_1 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("Welcome to the game, ", player_name_1, "!\n"))
cat("I'll enjoy playing with you!\n")
player_name_2 = "Commander Data"
} else if(n_player == 2){
cat("I'm glad that I can watch you two play. Please, tell me your names. You can communicate with me via the console! \n
Player 1:\n")
player_name_1 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("Welcome to the game, ", player_name_1,"!\n"))
cat("Player 2:\n")
player_name_2 = scan(what = "character", nlines = 1, quiet = T)
cat(paste0("You're welcome, too, ", player_name_2, "!\n"))
}
cat("So, let's start the game!\n" )
rules.hear = "a"
while(!rules.hear %in% c("yes", "start")){
cat("If you want to hear the rules again, type >>yes<<, if you want to start immediately, type >>start<<!\n")
rules.hear = scan(what = "character", nlines = 1, quiet = T)
if(length(rules.hear) == 0){
cat("Error. Unfortunately, I could not understand what you said.\n")
} else if(rules.hear == "yes"){
game_start = character(0)
rules.print()
while(length(game_start)==0){
cat("To start type anything (no space) into the console and press enter whenever you are ready to rumble!")
game_start = scan(what = "character", nlines = 1, quiet = T)
}
board.new(n_row, n_col)
} else if(rules.hear == "start"){
board.new(n_row, n_col)
} else {
cat("Error. Unfortunately, I could not understand what you said.\n")
}
}
player.order = sample(c(1,2))
start_move <- player.order[1]
player_names <<- c(player_name_1, player_name_2)
match_status <<- 1
cat(paste0(player_name_1, " VS. ", player_name_2, "\n"))
cat(paste0("Player ", start_move, " (", player_names[start_move], ") starts! \n In each move you have to choose one column!\n"))
moves_played <<- matrix(NA, ncol = 2, nrow = n_row*n_col)
colnames(moves_played) = player_names[player.order]
column_counts <<- rep(0, n_col)
field_mat <<- matrix(0, ncol = n_col, nrow = n_row)
move_seq <<-  rep(player.order, (n_col * n_row) / 2)
#if(start_move == 2) move_seq <<- (move_seq %% 2) + 1
}
connect_four(n_player = 1)
install.packages("rpact")
library(rpact)
help(rpact)
design = getDesignGroupSequential()
design
getDesignCharacteristics(design)
?getDesignGroupSequential
getSampleSizeMeans(design)
?getSampleSizeMeans
?getDesignGroupSequential
design = getDesignGroupSequential(kMax = 2, typeOfDesign = "OF", informationRates = 0.5)
design = getDesignGroupSequential(kMax = 1, typeOfDesign = "OF", informationRates = 0.5)
design
design = getDesignGroupSequential(kMax = 2, typeOfDesign = "OF")
design
getDesignCharacteristics(design)
getSampleSizeMeans(design)
design = getDesignGroupSequential(kMax = 2, typeOfDesign = "OF")
design
getDesignCharacteristics(design)
getSampleSizeMeans(design, thetaH0 = 8, stDev = 18)
getSampleSizeMeans(design, thetaH0 = 8, stDev = 18, alternative = seq(8, 16, 1))
getSampleSizeMeans(design, thetaH0 = 8, stDev = 18, alternative = seq(9, 16, 1))
DF <- data.frame(x = c(1, 2, 3), y = c(0, 10, NA))
na.omit(DF)
prec.r = paste0(c("MSE", "MAE"), rep(c("np_", "w_"), each = 5), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd"))
prec.r
prec.r = paste0(c("MSE_", "MAE_"), rep(c("np_", "w_"), each = 5), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd"))
prec.r
prec.r = paste0(c("MSE_", "MAE_"), rep(paste0((c("np_", "w_"), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd"))), each = 5))
prec.r = paste0(c("MSE_", "MAE_"), rep(paste0(c("np_", "w_"), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd")), each = 5))
prec.r
prec.r = paste0(rep(c("MSE_", "MAE_"), each = 5), rep(paste0(c("np_", "w_"), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd")), each = 5))
prec.r
prec.r = paste0(rep(c("MSE_", "MAE_"), each = 5), paste0(c("np_", "w_"), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd")))
prec.r
paste0(c("np_", "w_"), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd"))
paste0(rep(c("np_", "w_"), each = 5), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd"))
prec.r = paste0(rep(c("MSE_", "MAE_"), each = 5), paste0(rep(c("np_", "w_"), each = 5), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd")))
prec.r
prec.r = paste0(rep(c("MSE_", "MAE_"), each = 10), paste0(rep(c("np_", "w_"), each = 5), c("0.25 Q", "0.5 Q", "Mean", "0.75 Q", "Sd")))
prec.r
A = data.frame(y = rnorm(10))
A
B = data.frame(c("A", "B") = NA)
B = cbind(A, matrix(NA, ncol = 2, nrow = nrow(A)))
B
library(microbenchmark)
a = microbenchmark(mean(rnorm(10)))
a
a
print(a)
a$time
mean(a$time)
summary(a$time/1000)
a$expr
nboots = c(10, 100, 500, 1000, 10000) # define different bootstrap iterations
n      = c(5, 10, 15, 20, 50, 100, 200) # define different sample sizes
nboots = c(10, 100, 500, 1000, 10000) # define different bootstrap iterations
n      = c(5, 10, 50, 100, 200) # define different sample sizes
library(gridExtra)
p1 = qplot(rexp(10), rnorm(10))
library(ggplot2)
p1 = qplot(rexp(10), rnorm(10))
p2 = qplot(rf(10, 1, 2), rnorm(10))
p2
p1
l = list(p1, p2)
grid.arrange(l, nrow = 1)
do.call("grid.arrange", l)
do.call("grid.arrange", l, nrow = 1)
do.call("grid.arrange", c(l, nrow = 1))
p3 = qplot(rt(10,2), rnorm(10))
p4 = qplot(runif(10), rnorm(10))
l = list(p1,p2,p3,p4)
do.call("grid.arrange", c(l, nrow = 2))
nboots = c(10, 100, 500, 1000, 10000) # define different bootstrap iterations
n      = c(5, 10, 50, 100, 200) # define different sample sizes
dat.R  = expand.grid(nboots, n)
colnames(dat.R) = c("nboots", "n")
dat.R
ggplot(mapping = aes(x = rnorm(10), y = rt(10, 2))) + geom_point()
ggplot(mapping = aes(x = rnorm(10), y = rt(10, 2))) + geom_point()
1
6
seq(1, nrow(dat.R), 5))
seq(1, nrow(dat.R), 5)
for(i in seq(1, nrow(dat.R), 5)){
print(i * (1:5))
#l.p[[i]] = ggplot(mapping = aes(x = dat.R[i * (1:5), "MSE_np_Mean"]))
}
for(i in seq(1, nrow(dat.R), 5)){
print(i + (0:4))
#l.p[[i]] = ggplot(mapping = aes(x = dat.R[i * (1:5), "MSE_np_Mean"]))
}
library(plotly)
install.packages("plotly")
library(plotly)
temp <- rnorm(100, mean=30, sd=5)
pressure <- rnorm(100)
dtime <- 1:100
plot_ly(x=temp, y=pressure, z=dtime, type="scatter3d", mode="markers", color=temp)
getwd()
png(file = "test1.png")
plot_ly(x=temp, y=pressure, z=dtime, type="scatter3d", mode="markers", color=temp)
dev.off()
p.test = plot_ly(x=temp, y=pressure, z=dtime, type="scatter3d", mode="markers", color=temp)
export(p.test)
ggplot()
?save
mae.fun = function(x, value){
return(mean(abs(x - value)))
}
a = rnorm(10)
mae.fun(a, 0)
mae.fun(a, c(1:10))
abs(a - c(1:10))
abs(a - 0)
a = matrix(rnorm(30), ncol = 6)
mae.fun(a, c(1:10))
mae.fun(a, c(1:5))
A = matrix(c(1:20), ncol = 5)
A
A - 1
mae.fun.comp = function(x, values){
return(mean(rowMeans(abs(x -  values))))
}
mse.fun.comp = function(x, values){
return(mean(rowMeans((x -  values)^2)))
}
# True values Normal
q.025 = qnorm(0.25)
f_test = function(x){
(x-2) / (4 * exp(-2*x))
}
curve(f_test, -5, 10)
f_test(0)
curve(f_test, -1, 1)
f_test(1)
f_test(2)
curve(f_test, 0, 1)
curve(f_test, 0, 2)
f_test(1.5)
A.temp.r.np
warn
getOption("warn")
setwd("D:/Dropbox/Studium/M.Sc. Statistics/Semester III/NIC/code")
pkgs = c("Rcpp", "RcppArmadillo", "microbenchmark", "ggplot2", "gridExtra", "xtable")
if(pkgs %in% installed.packages() == F) install.packages(pkgs = pkgs, dependencies = T)
lapply(as.list(pkgs), library, quietly = T, character.only = T)
############################################
############# Source Functions #############
############################################
# These load the respective scripts containing the functions. Note,
# that these scrips already load the cpp-functions into the environment.
# However, only use them carefully. There are R-wrappers making use of them
# to embed them properly.
source("summary.R") # Bootstrap Summary aka Parameter Estimation
source("t_test.R") # Bootstrap t-Test
source("regression.R") # Bootstrap Linear Regression
nboots = c(10, 100, 500, 1000, 10000) # define different bootstrap iterations
n      = c(5, 10, 50, 100, 200) # define different sample sizes
base_grid  = expand.grid(nboots, n)
colnames(base_grid) = c("nboots", "n")
dat.Cpp  = dat.R = base_grid
mae.fun = function(x, value){
return(mean(abs(x - value)))
}
mse.fun = function(x, value){
return(mean((x - value)^2))
}
mae.fun.comp = function(x, values){
return(mean(rowMeans(abs(x -  values))))
}
mse.fun.comp = function(x, values){
return(mean(rowMeans((x -  values)^2)))
}
set.seed(314)
beta = runif(4, -20, 20)
prec = matrix(NA, ncol = 4, nrow = nrow(base_grid))
colnames(prec) = c("MSE_np", "MSE_w", "MAE_np", "MAE_w")
dat.Cpp  = dat.R = cbind(base_grid, prec)
time.r = time.c = matrix(NA, nrow = nrow(dat.R), ncol = 6)
i = 1
x = cbind(sample(c(30:100), size = dat.R$n[i], replace = T), runif(dat.R$n[i], 50, 230), log(rnorm(dat.R$n[i], 100, 7.5)), rnorm(dat.R$n[i], 100, 7.5))
y = x%*%beta + rnorm(dat.R$n[i])
time.r[i,] = summary(microbenchmark(reg.boot(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000) # microseconds
time.c[i,] = summary(microbenchmark(reg.boot.c(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000)
i = 2
x = cbind(sample(c(30:100), size = dat.R$n[i], replace = T), runif(dat.R$n[i], 50, 230), log(rnorm(dat.R$n[i], 100, 7.5)), rnorm(dat.R$n[i], 100, 7.5))
y = x%*%beta + rnorm(dat.R$n[i])
time.r[i,] = summary(microbenchmark(reg.boot(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000) # microseconds
time.c[i,] = summary(microbenchmark(reg.boot.c(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000)
time.c
time.r = time.c = matrix(NA, nrow = nrow(dat.R), ncol = 6)
for(i in 1:nrow(dat.R)){
# A.temp.r.np = A.temp.r.w = A.temp.c.np = A.temp.c.w = matrix(NA, nrow = length(beta), ncol = 1000)
# for(j in 1:1000){
#         # structure of X is: one variable coming (discrete) uniformly from 30 to 100, one (continuously) from 50 to 230
#         # one is log(normal) and one is normally distributed around 100 with sd 7.5
#         x = cbind(sample(c(30:100), size = dat.R$n[i], replace = T), runif(dat.R$n[i], 50, 230), log(rnorm(dat.R$n[i], 100, 7.5)), rnorm(dat.R$n[i], 100, 7.5))
#         y = x%*%beta + rnorm(dat.R$n[i])
#         A.temp.r.np[,j] = tryCatch(reg.boot(y, x, nboot = dat.R$nboots[i], intercept = F)$estimate, error=function(cond){return(NA)}) # maybe trycatch
#         A.temp.r.w[,j] = reg.boot(y, x, nboot = dat.R$nboots[i], boot.type = "wild", intercept = F)$estimate
#         A.temp.c.np[,j] = tryCatch(reg.boot.c(y, x, nboot = dat.R$nboots[i], intercept = F)$estimate, error=function(cond){return(NA)})
#         A.temp.c.w[,j] = reg.boot.c(y, x, nboot = dat.R$nboots[i], boot.type = "wild", intercept = F)$estimate
# }
# dat.R$MSE_np = mse.fun.comp(A.temp.r.np, beta)
# dat.R$MSE_w  = mse.fun.comp(A.temp.r.w, beta)
# dat.R$MAE_np = mae.fun.comp(A.temp.r.np, beta)
# dat.R$MAE_w  = mae.fun.comp(A.temp.r.w, beta)
#
# dat.Cpp$MSE_np = mse.fun.comp(A.temp.c.np, beta)
# dat.Cpp$MSE_w  = mse.fun.comp(A.temp.c.w, beta)
# dat.Cpp$MAE_np = mae.fun.comp(A.temp.c.np, beta)
# dat.Cpp$MAE_w  = mae.fun.comp(A.temp.c.w, beta)
x = cbind(sample(c(30:100), size = dat.R$n[i], replace = T), runif(dat.R$n[i], 50, 230), log(rnorm(dat.R$n[i], 100, 7.5)), rnorm(dat.R$n[i], 100, 7.5))
y = x%*%beta + rnorm(dat.R$n[i])
time.r[i,] = summary(microbenchmark(reg.boot(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000) # microseconds
time.c[i,] = summary(microbenchmark(reg.boot.c(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000)
print(i)
}
dat.R$n[3]
i
x = cbind(sample(c(30:100), size = dat.R$n[i], replace = T), runif(dat.R$n[i], 50, 230), log(rnorm(dat.R$n[i], 100, 7.5)), rnorm(dat.R$n[i], 100, 7.5))
y = x%*%beta + rnorm(dat.R$n[i])
time.r[i,] = summary(microbenchmark(reg.boot(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000) # microseconds
time.c[i,] = summary(microbenchmark(reg.boot.c(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000)
for(i in 4:nrow(dat.R)){
# A.temp.r.np = A.temp.r.w = A.temp.c.np = A.temp.c.w = matrix(NA, nrow = length(beta), ncol = 1000)
# for(j in 1:1000){
#         # structure of X is: one variable coming (discrete) uniformly from 30 to 100, one (continuously) from 50 to 230
#         # one is log(normal) and one is normally distributed around 100 with sd 7.5
#         x = cbind(sample(c(30:100), size = dat.R$n[i], replace = T), runif(dat.R$n[i], 50, 230), log(rnorm(dat.R$n[i], 100, 7.5)), rnorm(dat.R$n[i], 100, 7.5))
#         y = x%*%beta + rnorm(dat.R$n[i])
#         A.temp.r.np[,j] = tryCatch(reg.boot(y, x, nboot = dat.R$nboots[i], intercept = F)$estimate, error=function(cond){return(NA)}) # maybe trycatch
#         A.temp.r.w[,j] = reg.boot(y, x, nboot = dat.R$nboots[i], boot.type = "wild", intercept = F)$estimate
#         A.temp.c.np[,j] = tryCatch(reg.boot.c(y, x, nboot = dat.R$nboots[i], intercept = F)$estimate, error=function(cond){return(NA)})
#         A.temp.c.w[,j] = reg.boot.c(y, x, nboot = dat.R$nboots[i], boot.type = "wild", intercept = F)$estimate
# }
# dat.R$MSE_np = mse.fun.comp(A.temp.r.np, beta)
# dat.R$MSE_w  = mse.fun.comp(A.temp.r.w, beta)
# dat.R$MAE_np = mae.fun.comp(A.temp.r.np, beta)
# dat.R$MAE_w  = mae.fun.comp(A.temp.r.w, beta)
#
# dat.Cpp$MSE_np = mse.fun.comp(A.temp.c.np, beta)
# dat.Cpp$MSE_w  = mse.fun.comp(A.temp.c.w, beta)
# dat.Cpp$MAE_np = mae.fun.comp(A.temp.c.np, beta)
# dat.Cpp$MAE_w  = mae.fun.comp(A.temp.c.w, beta)
x = cbind(sample(c(30:100), size = dat.R$n[i], replace = T), runif(dat.R$n[i], 50, 230), log(rnorm(dat.R$n[i], 100, 7.5)), rnorm(dat.R$n[i], 100, 7.5))
y = x%*%beta + rnorm(dat.R$n[i])
time.r[i,] = summary(microbenchmark(reg.boot(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000) # microseconds
time.c[i,] = summary(microbenchmark(reg.boot.c(y, x, nboot = dat.R$nboots[i], boot.type = "wild"))$time / 1000)
print(i)
}
warnings()
time.r
time.c
max(time.c)
max(time.c) - max(time.r)
a.test = matrix(rnorm(20, 5, 1), ncol = 5)
(rowSums(a.test^2) - 4*rowMeans(a.test)^2)/3
(rowSums(a.test^2) - 5*rowMeans(a.test)^2)/4
l.p = list()
#for(i in seq(1, nrow(dat.R), 5)){
for(i in 1:5)
{}
l.p = list()
#for(i in seq(1, nrow(dat.R), 5)){
for(i in 1:5){
# l.p[[i]] = ggplot()+
#     geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = dat.R[i + c(0:4), "MSE_np"]), color = "red") +
#     geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = dat.R[i + c(0:4), "MSE_w"]), color = "blue") +
#     labs(x = "Bootstrap Iterations", y = "MSE")
#
# l.p[[i + 1]] = ggplot()+
#     geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = dat.R[i + c(0:4), "MAE_np"]), color = "red") +
#     geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = dat.R[i + c(0:4), "MAE_w"]), color = "blue") +
#     labs(x = "Bootstrap Iterations", y = "MAE")
#
# l.p[[i + 2]] = ggplot()+
#     geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = dat.Cpp[i + c(0:4), "MSE_np"]), color = "red") +
#     geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = dat.Cpp[i + c(0:4), "MSE_w"]), color = "blue") +
#     labs(x = "Bootstrap Iterations", y = "MSE")
#
# l.p[[i + 3]] = ggplot()+
#     geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = dat.Cpp[i + c(0:4), "MAE_np"]), color = "red") +
#     geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = dat.Cpp[i + c(0:4), "MAE_w"]), color = "blue") +
#     labs(x = "Bootstrap Iterations", y = "MAE")
l.p[[i ]] = ggplot()+
geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = time.r[i + c(0:4), 3]), color = "red")+
geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = time.c[i + c(0:4), 3]), color = "blue") +
labs(x = "Bootstrap Iterations", y = "Microseconds")
}
summary_plot = do.call("grid.arrange", c(l.p, nrow = 5, ncol = 5))
summary_plot = do.call("grid.arrange", c(l.p, nrow = 5))
time.r
log(time.r)
log(time.c)
max(log(time.r) - log(time.c))
l.p = list()
#for(i in seq(1, nrow(dat.R), 5)){
for(i in 1:5){
# l.p[[i]] = ggplot()+
#     geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = dat.R[i + c(0:4), "MSE_np"]), color = "red") +
#     geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = dat.R[i + c(0:4), "MSE_w"]), color = "blue") +
#     labs(x = "Bootstrap Iterations", y = "MSE")
#
# l.p[[i + 1]] = ggplot()+
#     geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = dat.R[i + c(0:4), "MAE_np"]), color = "red") +
#     geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = dat.R[i + c(0:4), "MAE_w"]), color = "blue") +
#     labs(x = "Bootstrap Iterations", y = "MAE")
#
# l.p[[i + 2]] = ggplot()+
#     geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = dat.Cpp[i + c(0:4), "MSE_np"]), color = "red") +
#     geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = dat.Cpp[i + c(0:4), "MSE_w"]), color = "blue") +
#     labs(x = "Bootstrap Iterations", y = "MSE")
#
# l.p[[i + 3]] = ggplot()+
#     geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = dat.Cpp[i + c(0:4), "MAE_np"]), color = "red") +
#     geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = dat.Cpp[i + c(0:4), "MAE_w"]), color = "blue") +
#     labs(x = "Bootstrap Iterations", y = "MAE")
l.p[[i ]] = ggplot()+
geom_line(mapping = aes(x = dat.R[i + c(0:4), "nboots"], y = log(time.r[i + c(0:4), 3])), color = "red")+
geom_line(mapping = aes(x = dat.Cpp[i + c(0:4), "nboots"], y = log(time.c[i + c(0:4), 3])), color = "blue") +
labs(x = "Bootstrap Iterations", y = "Log-Microseconds")
}
summary_plot = do.call("grid.arrange", c(l.p, nrow = 5))
ggsave("./resuls/plot_regression.pdf", plot = summary_plot, dpi = 300, width = 16, height = 9)
getwd()
load("./results/reg_data.RData")
dat.Cpp
reg_plot = do.call("grid.arrange", c(l.p, nrow = 5))
ggsave("./resuls/plot_regression.pdf", plot = reg_plot, dpi = 300, width = 16, height = 9)
ggsave("./resutls/plot_regression.pdf", plot = reg_plot, dpi = 300, width = 16, height = 9)
ggsave("./results/plot_regression.pdf", plot = reg_plot, dpi = 300, width = 16, height = 9)
